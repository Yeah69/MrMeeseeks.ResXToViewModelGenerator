using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MrMeeseeks.ResXToViewModelGenerator;

internal record SingularProperty(string Name, string BackingFieldName, string Value);

internal record PluralProperty(string Name, string BackingFieldName, IReadOnlyDictionary<string, string> Value);

internal record LocalizationFileDescription(
	string Name,
	string LanguageCode,
	IReadOnlyList<SingularProperty> SingularProperties,
	IReadOnlyList<PluralProperty> PluralProperties);

internal static class Templating
{
	internal static string Render(
		string @namespace,
		string name,
		IReadOnlyDictionary<string, IValue> defaultKeyValues,
		IReadOnlyDictionary<string, IReadOnlyDictionary<string, IValue>> culturalKeyValues)
	{
		var implementations = culturalKeyValues
			.Select(kvp => Create(kvp.Key, kvp.Key, kvp.Value))
			.Prepend(Create("Default", "iv", defaultKeyValues))
			.Append(Create("Key", "iv", defaultKeyValues
				.ToDictionary(kvp => kvp.Key, kvp => kvp.Value switch
				{
					IPlainString => (IValue) new PlainString(kvp.Key),
					IPluralStrings pluralStrings => new PluralStrings(pluralStrings.Value.ToDictionary(kvp0 => kvp0.Key, kvp0 => $"{kvp.Key}.{kvp0.Key}")),
					_ => throw new InvalidOperationException("Shouldn't be possible!")
				})))
			.ToList();

		var code = new StringBuilder();
		code.AppendLine(
			$$"""
			  #nullable enable
			  using System;
			  using System.Collections.Generic;
			  using System.Collections.ObjectModel;
			  using System.ComponentModel;
			  using System.Globalization;

			  // ------------------------------------------------------------------------------
			  // <auto-generated>
			  // 	This code was generated by a tool.
			  //
			  // 	Changes to this file may cause incorrect behavior and will be lost if
			  // 	the code is regenerated.
			  // </auto-generated>
			  // ------------------------------------------------------------------------------


			  namespace {{@namespace}}
			  {
			  	public interface I{{name}}ViewModel : INotifyPropertyChanged
			  	{
			  		CultureInfo CultureInfo { get; }
			  """);
		foreach (var propertyName in implementations[0].SingularProperties.Select(p => p.Name))
		{
			code.AppendLine($"		string {propertyName} {{ get; }}");
		}
		foreach (var propertyName in implementations[0].PluralProperties.Select(p => p.Name))
		{
			code.AppendLine($"		IReadOnlyDictionary<string, string> {propertyName} {{ get; }}");
		}

		code.AppendLine(
			$$"""
			  
			  		ISettable{{name}}ViewModel AsSettable();
			  	}
			  	public interface ISettable{{name}}ViewModel : INotifyPropertyChanged
			  	{
			  """);
		foreach (var propertyName in implementations[0].SingularProperties.Select(p => p.Name))
		{
			code.AppendLine($"		string {propertyName} {{ set; }}");
		}
		foreach (var propertyName in implementations[0].PluralProperties.Select(p => p.Name))
		{
			code.AppendLine($"		IReadOnlyDictionary<string, string> {propertyName} {{ set; }}");
		}

		code.AppendLine(
			$$"""
			  
			  	}
			  
			  	public interface I{{name}}OptionViewModel : INotifyPropertyChanged
			  	{
			  		CultureInfo CultureInfo { get; }
			  	}
			  
			  	public interface ICurrent{{name}}ViewModel : INotifyPropertyChanged
			  	{
			  		I{{name}}ViewModel Current{{name}} { get; }
			  
			  		I{{name}}OptionViewModel CurrentOption { get; set; }
			  
			  		IReadOnlyList<I{{name}}OptionViewModel> AvailableOptions { get; }
			  
			  		void ShowKeys();
			  	}
			          
			  	public sealed class Current{{name}}ViewModel : ICurrent{{name}}ViewModel
			  	{
			  		private I{{name}}ViewModel _current{{name}};
			  		private I{{name}}OptionViewModel _currentOption;
			  		public event PropertyChangedEventHandler? PropertyChanged;
			  
			  		public Current{{name}}ViewModel()
			  		{
			  			AvailableOptions = new ReadOnlyCollection<I{{name}}OptionViewModel>(
			  				new List<I{{name}}OptionViewModel>
			  				{
			  """);
			
		foreach (var resXImplementation in implementations.Take(implementations.Count - 1))
		{
			code.AppendLine($"					new {resXImplementation.Name }{name}OptionViewModel(),");
		}

		code.AppendLine(
			$$"""
			  
			  				});
			  			_currentOption = AvailableOptions[0];
			  			_current{{name}} = Create{{name}}(_currentOption);
			  		}
			  
			  		public I{{name}}OptionViewModel CurrentOption
			  		{
			  			get => _currentOption;
			  			set
			  			{
			  				if (_currentOption == value) return;
			  				_currentOption = value;
			  				_current{{name}} = Create{{name}}(value);
			  				PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(CurrentOption)));
			  				PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Current{{name}})));
			  			}
			  		}
			  
			  		private I{{name}}ViewModel Create{{name}}(I{{name}}OptionViewModel option) => ((option as I{{name}}OptionViewModelInternal) ?? new Default{{name}}OptionViewModel()).Create();
			  
			  		public I{{name}}ViewModel Current{{name}} => _current{{name}};
			  
			  		public void ShowKeys() => CurrentOption = new Key{{name}}OptionViewModel();
			  
			  		public IReadOnlyList<I{{name}}OptionViewModel> AvailableOptions { get; }
			  
			  		public interface I{{name}}OptionViewModelInternal : I{{name}}OptionViewModel
			  		{
			  			I{{name}}ViewModel Create();
			  		}

			  """);
			
		foreach (var implementation in implementations)
		{
			code.AppendLine(
				$$"""
				  		private class {{implementation.Name}}{{name}}OptionViewModel : I{{name}}OptionViewModelInternal
				  		{
				  #pragma warning disable 0067
				  			public event PropertyChangedEventHandler? PropertyChanged;
				  #pragma warning restore 0067
				  
				  			public CultureInfo CultureInfo
				  			{
				  				get
				  				{
				  					try
				  					{
				  						return CultureInfo.GetCultureInfo("{{implementation.LanguageCode}}");
				  					}
				  					catch (Exception)
				  					{
				  						// ignored
				  					}
				  					return CultureInfo.InvariantCulture;
				  				}
				  			}
				  
				  			public I{{name}}ViewModel Create() => new {{implementation.Name}}{{name}}ViewModel();
				  		}
				  """);
		}
			
		foreach (var implementation in implementations)
		{
			code.AppendLine(
				$$"""
				  		private class {{implementation.Name}}{{name}}ViewModel : I{{name}}ViewModel, ISettable{{name}}ViewModel
				  		{
				  #pragma warning disable 0067
				  			public event PropertyChangedEventHandler? PropertyChanged;
				  #pragma warning restore 0067
				  
				  			public CultureInfo CultureInfo
				  			{
				  				get
				  				{
				  					try
				  					{
				  						return CultureInfo.GetCultureInfo("{{implementation.LanguageCode}}");
				  					}
				  					catch (Exception)
				  					{
				  						// ignored
				  					}
				  					return CultureInfo.InvariantCulture;
				  				}
				  			}

				  """);
			foreach (var singularProperty in implementation.SingularProperties)
			{
				code.AppendLine(
					$$"""
					  			private string {{singularProperty.BackingFieldName}} = {{singularProperty.Value}};
					  			public string {{singularProperty.Name}}
					  			{
					  				get => {{singularProperty.BackingFieldName}};
					  				set
					  				{
					  					if({{singularProperty.BackingFieldName}} != value)
					  					{
					  						{{singularProperty.BackingFieldName}} = value;
					  						PropertyChanged?.Invoke(this, new PropertyChangedEventArgs("{{singularProperty.Name}}"));
					  					}
					  				}
					  			}
					  """);
			}
			foreach (var pluralProperty in implementation.PluralProperties)
			{
				code.AppendLine(
					$$"""
					  			private IReadOnlyDictionary<string, string> {{pluralProperty.BackingFieldName}} = new Dictionary<string, string> { {{string.Join(", ", pluralProperty.Value.Select(kvp => $"[{kvp.Key}] = {kvp.Value}"))}} };
					  			public IReadOnlyDictionary<string, string> {{pluralProperty.Name}}
					  			{
					  				get => {{pluralProperty.BackingFieldName}};
					  				set
					  				{
					  					if({{pluralProperty.BackingFieldName}} != value)
					  					{
					  						{{pluralProperty.BackingFieldName}} = value;
					  						PropertyChanged?.Invoke(this, new PropertyChangedEventArgs("{{pluralProperty.Name}}"));
					  					}
					  				}
					  			}
					  """);
			}

			code.AppendLine(
					$$"""
					  			public ISettable{{name}}ViewModel AsSettable() => this;
					  		}
					  """);
		}

		code.AppendLine(
			"""
				}
			}
			#nullable disable
			""");
			

		return code.ToString();


		static LocalizationFileDescription Create(
			string name,
			string languageCode,
			IReadOnlyDictionary<string, IValue> propertyMapping)
		{
			ISet<string> takenNames = new HashSet<string>(propertyMapping.Keys);
			return new(
				name.Replace("-", "_"), // Escape minuses of language codes for the names of types
				languageCode,
				propertyMapping
					.Where(kvp => kvp.Value is IPlainString)
					.Select(kvp => new SingularProperty(
						kvp.Key, 
						FindBackingFieldName(kvp.Key, takenNames), 
						ValueToLiteral(((IPlainString)kvp.Value).Value)))
					.ToList(),
				propertyMapping
					.Where(kvp => kvp.Value is IPluralStrings)
					.Select(kvp => new PluralProperty(
						kvp.Key, 
						FindBackingFieldName(kvp.Key, takenNames), 
						((IPluralStrings)kvp.Value).Value.ToDictionary(
							kvp0 => ValueToLiteral(kvp0.Key), 
							kvp0 => ValueToLiteral(kvp0.Value))))
					.ToList()
				);
				
			static string ValueToLiteral(string input) => 
				Microsoft.CodeAnalysis.CSharp.SymbolDisplay.FormatLiteral(input, true);

			static string FindBackingFieldName(string propertyName, ISet<string> takenNames)
			{
				var i = 0;
				// ReSharper disable once RedundantAssignment
				while ($"_{propertyName}{i++}" is {} backingFieldName && !takenNames.Contains(backingFieldName))
				{
					takenNames.Add(backingFieldName);
					return backingFieldName;
				}

				throw new InvalidOperationException("Shouldn't be possible!");
			}
		}
	}
}